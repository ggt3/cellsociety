CS 308: CellSociety analysis
===================

> This is the link to the Analysis Description: [Analysis - CellSociety](http://www.cs.duke.edu/courses/compsci308/spring15/assign/02_cellsociety/part4.php)

Project Journal
=======

###Time Review
We started collaborating on the 25th, meeting up to talk about design concepts and get through what the project specifications were. I estimate spending over 40 hours, and at least 5-7 hours just purely devoted to designing (and no coding). As a group, we definitely spent 15-20 hours together, either meeting up with one other group member or coding as three people. Initially there was a lot of time spent on implanting the new features (especially when there wasn’t a GUI yet). The first two days before there was any code written, we talked about how the simulations work, the types of classes we should have and the way to contain the cells and their states. I spent a lot of time working on the logic of the simulations and building a structure that allowed multiple different types of simulations. The hardest was decoding the simulations, and finding a way to structure the code in a way that could be extendable. I think we spent a lot of time structuring and decided what to do with our code, which made me feel like we devoted too much time to talking about what we should do, instead of implementing it. I think spending time on structuring the project before hand is good, but we didn’t do it in a way that was even in-depth, like making methods that each class would need. We couldn’t really envision the program until we were coding it and then realizing the methods we would need, so I felt like we should have gotten coding much sooner. I found the easier things to do were to connect existing views and the logic of the program, and to see it finally connect together and was rewarding, and a lot less frustrating than debugging the logic of the simulations. There was a lot of time spent towards the end of the project for refactoring our code, especially the view because making buttons and populating the view with objects can get repetitive. The hardest parts were the logic of the simulation and realizing that we couldn’t pass a grid by reference, and we had to make copies of grids. This mistake occurred a few times for me and it a lot of debugging before I realized that. 

###Teamwork
Like I said, our team met a lot in the beginning especially for writing the design document and some subsequent days after where we met together to get on the same page about how we should go about coding. To divide the work, I would say Cosi worked on the GUI, I worked on the Controller and the logic of the simulations and Robert did the XML parser. I think for the first sprint/ basic implementation, Cosi and I had to do a lot of the coding, even though Robert did help for ideas. He was quick to understand what our code was doing, but not helpful in actually getting stuff done. Many times he had wanted to help out but wasn’t sure quite what to do. I got help from another TA (Dan Li) on design ideas and he talked to my group about things we should do when considering a grid of rule types or different types of cell types. He told us about the model view controller design and how that was good for this project. I don’t think we explicitly chose roles for ourselves before hand, but naturally just migrated towards doing different parts of the project. We weren’t limited to those jobs either; Cosi and Robert helped look over some of the logic of the simulations and I looked over Cosi’s code on the GUI and helped her refactor her code.  
I think our team had great devotion to meeting up for group meetings and communicated through message. However there were times when not everyone was coding so if there was a message sent, it may not have been responded to till much later. Also sometimes because we couldn’t meet much when all three of us were there, I tried to at least send updates about what we decided the other group member needed to do in terms of the code. I think the amount of communication was about right with this group. Not too many messages, but just enough. A problem for us was finding times when we could all meet together – we had a lot of conflicts and commitments. We did not make plans or deadlines for ourselves but we had a checklist of things that we need to fix whenever they came up. I think we modified our plan a little, but in general stuck with the idea that the controller passed information back and forth between the view and the model. We never created a timeline for ourselves, things just connected together naturally as we progressed through the project. 

###Commits
I committed to master 36 times, and it’s really hard to give an average estimate, but I think there were commits anywhere from 5 – 200+ additions. Some of the smaller additions were because team members were working on the project and I wanted an updated version, some of the commits were actually me trying to learn how to use github, so I would commit some of the code I had but then realize there was code that I didn’t add to the commit yet that was supposed to be together in the commit, so I immediately pushed it right after, leading to a few additions in one commit. There were merge conflicts in our code, however these were easily resolved because we would be coding with each other so it was quick to solve.  
Trying to learn from last time, I wanted to commit code whenever I was done with a feature, however it took me a long time to get to a satisfactory stopping point, and my team members would be starting to code and I wanted them to have the most up to date version, so sometimes I would push mid feature. Also when we pair programmed we would commit code just so the other person had the most updates commit so they could work from there. Towards the end of the project, I kept on forgetting to check out my own branch so a lot of the times I found myself working from master, which could have been dangerous. Looking back at my commit messages, I think I could have added more description when I was merging my own branch with master because “merge” is not very specific. For the most part, I think my messages reflect the work/ and the parts of the project that I worked on. There was one night especially where we team programmed on my computer and I tried to give credit where that was due: [example](https://github.com/duke-compsci308-spring2015/cellsociety_team10/commit/d87eeaae3f8856a0b829b15435dcca3041230313)
#####	Commit Message Examples:
1. [“refactored displayGrid to create subclass triangles grid or rectangle grid”](https://github.com/duke-compsci308-spring2015/cellsociety_team10/commit/1a4e2cd368f11ea9725b2c12f44b321e67bb893b)  
The purpose of this commit is basically the commit message: I made the types of grids that the view displayed their own class so that it wasn’t in displayGrid class. This allows for the extensibility of having different view types without making one class longer and longer with if statements and different ways to draw the grid. This code did not have merge conflicts with others’ code. But this commit was done at a time when all three of us were working together so that we could coordinate and prevent some merge conflicts. It was done at a timely manner because this was towards the end of the project and we were trying to find places where the code could be refactored.  
2. [“added a tester class and made a copy method for the grid”](https://github.com/duke-compsci308-spring2015/cellsociety_team10/commit/c62cca92dca9da5c1968a3c284050136c145618d)  
This commit was to add a class that could test the view by making manual grids because we didn’t have an XML parser at that time. I also realized that we needed to make deep copies of the grid that is being passed back and forth. This commit was good timing because we had just finished the view and had wanted to test if rectangles would show up for the grid. Also, I had finished writing logic of the simulations but I had no idea if they worked because it was hard to test without visuals. This new class and editing the grid class did not cause merge conflicts with anyone because they weren’t working those classes.  
3. [“fixed rules for segregation”](https://github.com/duke-compsci308-spring2015/cellsociety_team10/commit/770e5f4f68fd7b44d679997d46d4221825ef25ca)  
This was debugging my simulations when I realized the way the simulation was running was not right. After talking to a friend I realized I was calculating the neighbors in a wrong way, so I added a method that would calculate the correct neighbors and fixed the logic. This did not cause merge conflicts as other group members were not working on this code at all. 

###Conclusions
At the beginning of this project I felt lost and felt overwhelming despair for this project because that I didn’t see how our project could be done. For a long time I also could not understand what we were doing so that added to me feeling lost. I overestimated the project in the beginning, but then in sprint 2 (second extension) I underestimated our resolve to implement more features) and so we didn’t even attempt to do the extra simulations. While other people in my group didn’t really tell me what progress they had made, although I knew generally what they were supposed to work on, they never gave explicit progress reports. I always sent messages to my group members on what I was currently working on, and if there was anything that I expected from another group member to implement, based on what I found was needed from my code. I think Cosi and I did most of the work in the GUI and the actual logic of the code respectively. 
I think to be a better teammate it would be to continue communicating, but also instead of allowing my teammates laziness to cause my own laziness, be proactive in the code so that it guilt trips other team members to do work. To be a better designer, I think this will come with experience, but I think good design also requires you to be flexible and not get boxed in after establishing an initial design. 
I think something that our TA mentioned that we were not diligent about fixing was passing around immutable objects, or copies of objects. If I had more time I would like to work on this, including finding some way to change the enumerations so that each simulation type had its own enumeration of states of its own simulation and not all the simulations. 


Design Review
=======

###Status
There are some inconsistencies in which my group members do small things such as starting brackets, or including brackets for one line if statements. Some of the less intuitive methods are not as commented out with my other group members, and even was inconsistent in my own code because there were times when it seemed so intuitive to myself. I think the dependencies in the code are pretty easy to find, there were some dependencies that occured in loadFile method, where there had to be a certain order of events to ensure everything was instantialized properly. I don't think there are method names that take head scratching to understand. There may be some methods that do two things as opposed to extracting another method out of that and making each method separate in function.
1. Lets review the [PopulationGraph.java](https://github.com/duke-compsci308-spring2015/cellsociety_team10/blob/master/src/viewPackage/PopulationGraph.java) class which I didn't write or refactor code. This is a relatively small class, with only three methods and I think the method name addToList could have been clearer, such as what list it was and what int l was, like what exactly were we adding to the list. I think there are also shared resposabilities between the constructer and the makeGraph() method such as making the x and y axis in the makeGraph() method, and setting the labels of the axis. I think making the idea of a population graph be in its own class is good because then this could be applied to other programs. To extend this to a different game, you would have to pass in a map of the item to its count, or whatever you are graphing and currently this is done by adding everything to the view packager, however if it were counting enemies on screen, that number would some how have to be packaged together. So there should be a package superclass? or make this method specifically take in a map. It would be relatively easy adding it to a game, or a different seetting because all you need is total populations of things you want to graph, and this can be taken in by changing the method signature.

2. [ErrorDisplay.java](https://github.com/duke-compsci308-spring2015/cellsociety_team10/blob/master/src/viewPackage/ErrorDisplay.java) This is a class with one method in it but still a necessary class because it separates this error giving window, and allows it to be used in many areas, so that errors wouldn't need to be passed to a specific class that handles all of them, whereas this window can be made from within any class. There are a lot of raw numbers, and I think sizes were hard coded into the window. These could be made into variables which would allow for easier change wif things were added later. I think this class does not specify as an "error window" just as a window that you can place text in, which in our case, we used for error display. Either the name would have to change, or something about this class would have to get more specific in terms of actually handling errors. 


###Design
The simulations required data of thresholds and an initial grid, the control just took the grids the simulation gave it and translated it into colors and gave it to the view to display. The view passed to the controller any initial state related to the simulation (type of border). The flow of data mainly went like: load XML file, view gives the controller the file name, controller calls on the parser to return specific information, the controller passes it to the simulation and demand for a new grid. Our controller was the messenger between the grid to be returned from the simulation and the view. For adding a new simulation, depending on what types of information it needs, like cell states, or having patches of ground have qualities along with the cells, it would require a different use of logic in regards to the way the grid class is structured. Currently, for these simulations, the locations are analogous to the cells on them, however with a new type of simulation, a line would have to be drawn between the location and the cell themselves. This would be easy to do, as there could be a map of a state of each location to the coordinants (and the state would contain a reference to the cell thats at that location). a new simulation class would have to extend the superclass and there would have to be an extra if statement in the controller class.  
I worked on the simulations and the grid and the cell structure. Then I also worked on the controller. The controller class is a bit "do all" right now because it literally does the dirty work of translating the grid into the color component, and ideally if we made the initial states set by the user, the controller would have to translate from the colors to make an initial grid. There is an if statement that interprets what simulation to be running, and based off the type of simulation it always returns a grid. The controller then has a map of the colors to the states and translates the grid into an array list of colors. Using this, the view updates the colors of the shapes.  
Talking about it now, I think the controller should do less, and there should be another class that translates the grid to its color and vice versa, and it would hold the map of colors to states. This way, the controller only needs to delegate work, and not actually do the work itself. I tried to encapulate the data being passed back and forth in a structure called a viewPackager and a packager, however I wasn't consistent in using them. Another problem was that for the basic simulations I was not consistent referring to the locations were the cell was vs. the cells themselves. This didn't matter with the basic simulations, but it would matter for the extended simulations where there was a difference between the location and the cell.
I think a lot of the extra design implementations for the second sprint were very easy to implement in our code design. I never felt like I had to completely rehaul my code especially with the way we would calculate neighbors for the triangle implementation. Even for toroidial grid, I just made my existing Grid class into an abstract super grid class, and then had subclasses finite and toroidial grids.

###Alternate Designs
The original design handled the original expectations fully, with some of the logic not working out, but would theoretically work out. 
1. With our TA, we considered a balanced relationship between our cells and our grid -- how much information each needed to know, and decided that we would have the cells know minimally close to nothing -- they only knew about themselves, and the grid would be responsible for spitting out the neighbors of the cell. This was good because it was easy to do finite and toroidral. 
2. we also considered our options with splitting up the view instead of having all the buttons in one class, we made the view "master" contain a button box, a togglespeed, and part of the other gui. This way, you could theoretically add and remove things from the view, allowing for a flexible GUI.
Some of the biggest issues are the way the information of grid initial states are passed back and forth between the view and the controller. I think it would be easier to do a changelistener, or observer which would cut down the translating between colors and states and allow easier user functionality. I prefer this way because there is less of a middle man and it is cleaner, there is not a place where the grid could get manipulated in translation. This also would allow the controller class to have more of a delegation job instead of physically doing all the work.  
Another issue is how there is if statements for different types of creations which could be done using a factory instead of having one method that is a bunch of if statements that get longer and longer. There were multiple places where a factory would have been useful, and as there gets to be more new features, a factory would keep the controller clean, and continue the trend of delegation.

Code Masterpiece
================
I chose to refactor the controller class and make some of the jobs of translating in the view packager because it is where the map is being updated, so putting it in one class would make it simpler. This makes the job of the controller cleaner and more isolated, and combine the function of the viewPackager with methods that already modify the variables in the class. The controller does not need to know how the translation occurs, just that this class will have the maps that the view needs. This way there is a level of abstraction made.
